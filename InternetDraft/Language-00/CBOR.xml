<!-- Copyright 2025 RiverExplorer LLC and Douglas Mark Royer -->

<section xmlns:xi="http://www.w3.org/2001/XInclude">
	<name>CLS Type</name>
	<section>
		<name>CLS Type</name>
		<t>
			The meaning of "CLS TYPE" in this specification refers
			to a data type as a "C" code API type.
			The "C" language was chosen because many other languages
			have methods of calling and using "C" APIs methods and data.
		</t>
		<t>
			For every "CLS TYPE" "foo", is a "C" code API of "cbor_foo(...)"
			that can encode and decode the data to and from a CBOR
			over the wire value.
			The "CLS TYPE" is normative.
			The "C" API is informative and meant as a guide to
			implementors.
		</t>
		<t>
			The UTC value used in this specification is designed
			to be compatible with time_t on <xref target="POSIX"/>
			compliant systems.
			In POSIX systems, time_t is defined as an integer type used for
			representing time in seconds since the UNIX epoch, which
			is 00:00:00 UTC on January 1, 1970.
			And in this specification is 64-bit unsigned integer.
		</t>
		<t>
			Arrays are used in a lot of data flows.
			String are always an array of printable characters.
			Some data needs to be converted to a from
			network byte order.
			Data that does not need to be converted to and
			from network byte order is called 'opaque' data.
			A PNG file is an example of opaque data.
			The PNG data itself is defined so that it is readable
			without any additional encoding.
		</t>
		<t>
			In this CBOR Language Specification (CLS), a
			data type that is an array, is fixed in length,
			or variable in length.
		</t>
		<t>
			A fixed array:
		</t>
		<ul>
			<li>
				A fixed array has its length surrounded by square
				brackets '[' and ']'.
			</li>
			<li>
				Each element in a fixed array is exactly the same size.
			</li>
			<li>
				The total size of a fixed array is calculated by multiplying
				the array length by the size of each element in the fixed array.
			</li>
			<li>
				A fixed size array can never be empty or null.
			</li>
		</ul>
		<t>
			A variable sized array.
			A variable array is one of two types:
		</t>
		<ul>
			<li>It is an array of UTF-8 characters, a string.</li>
			<li>Or it is an array of some non string data type.</li>
		</ul>
		<t>
			Common to all variable array types:
		</t>
		<ul>
			<li>
				<t>
				Both a string and non-string variable array
				may have a maximum length surrounded by angle
				brackets:
				</t>
				<t>
					'&lt;' max-length '&gt;'.
				</t>
			</li>
			<li>
				<t>
					Or they specify an unlimited length
					by having empty angle brackets, no maximum length
					specified.
					In this context 'unlimited' means not pre-defined.
				</t>
				<t>
					'&lt;&gt;'.
				</t>
			</li>
			<li>
				<t>
					Any variable array may have zero entries at
					run time.
					This is an empty array and is valid in
					this language specification.
				</t>
			</li>
			<li>
				<t>
					Any variable arrays may be null at run time.
					This is an null array and is valid in
					this language specification.
					And are transmitted as CBOR 'null' values.
				</t>
			</li>
		</ul>
		<t>
			Non-string variable arrays:
		</t>
		<ul>
			<li>
				Non-string variable arrays are defined by specifying
				their data type, and their optional maximum length.
			</li>
			<li>
				Variable arrays that are not string arrays have
				their total size calculated by multiplying
				the array length (which may or might not be
				the same as any optional maximum length)
				by the size of each element
				in the variable array.
				A non-string variable array size is always
				less than or the same as any optional
				maximum length.
			</li>
			<li>
				All elements in a non-string variable array
				have exactly the same size.
			</li>
		</ul>
		<t>
			String variable arrays:
		</t>
		<ul>
			<li>
				A variable array of UTF-8 characters is a 'string' array.
				String arrays are defined using the 'string' data type.
			</li>
			<li>
				<t>
					Variable arrays that are string arrays (a string
					data type) have their
					total size calculated by adding up the number of
					octets in all of the characters in the array.
					Which may or might not be the same as any
					optional maximum length.
					And the size (octet count) may be up to 4 times the maximum
					length (character count).
					Each UTF-8 character may be 1, 2, 3, or 4 octets
					in size.
				</t>
				<t>
					This is why a 'string' can not be a fixed size array, as
					you may not know the total number of octets when
					generating the code.
					And clipping off parts of a UTF-8 4, 3, or 2
					octet character makes the string useless.
					If a string was a fixed array, then you have
					to describe how to pad the unused
					values each time, and decide on left or right padding.
				</t>
			</li>
		</ul>

		<table>
			<name>CLC strings and arrays.</name>
			<thead>
				<tr>
					<th>
						NAME
					</th>
					<th>
						Description:
					</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>
						string
					</td>
					<td>
						<ul>
							<li>
								A string is always a variable array.
								If you need a fixed size character array, use a fixed
								array of 8 (ASCII), 16 (UTF-16), or 32 (UTF-32), values.
							</li>
							<li>
								A string may contain zero characters, this is an
								empty string.
							</li>
							<li>
								A string be null, in which is valid and
								is transmitted as a CBOR 'null'.
							</li>
							<li>
								A string is an array of UTF-8 printable characters.
								With an optional maximum length.
							</li>
							<li>
								A string is an array of printable characters.
								And each character may be 1, 2, 3, or 4 octets
								in size.
								The length specifies the number of printable characters
								in the string not the size of the array.
								This is also why a string can not be a fixed array.
							</li>
							<li>
								The octet count (size) of any string, could be the same
								as the number of characters (length),
								or the size could be up to 4 times larger.
							</li>
							<li>
								The length is the number of characters in the array.
							</li>
							<li>
								The size is the number of octets in the array.
							</li>
							<li>
								The length is always equal to or less than
								the size.
							</li>
						</ul>
							<artwork type="asciiart">
// A string variable array of printable characters,
// unlimited in length.
//
string MyVariableName&lt;&gt;;

// A string variable array of printable characters,
// up to 25 characters in length.
// And up to 100 octets is size.
//
string MyVariableName2&lt;25&gt;;
							</artwork>
					</td>
				</tr>
				<tr>
					<td>
						opaque
					</td>
					<td>
						<ul>
							<li>
								An opaque array is an array of 8-bit octets.
								And will not be network byte encoded or decoded.
							</li>
							<li>
								The size and length of an opaque array are
								always the same value.
							</li>
						</ul>
						<artwork type="asciiart">
// This is a fixed array that is always 42 octets in size.
// All 'opaque' objects are 8-bit values.
//
opaque MyOpaqueData[42];   

// A variable length array up to 42 octets in size.
//
opaque MyOpaqueData&lt;42&gt;;

// A variable length array of unlimited number of 8-bit octets.
//
opaque MyOpaqueData&lt;&gt;;
						</artwork>
					</td>
				</tr>
			</tbody>
		</table>
		<t>
			Arrays in CBOR have a "&lt;&gt;" in them to indicate they are arrays.
		</t>
		<figure>
			<artwork type="abnf" name="" alt=""><![CDATA[
			CBOR:
			string StringOfCharacters<>;
			Widget ArrayOfWidget<>;
			opaque PNGFileData<>;
]]></artwork>
		</figure>
		<t>
			Where:
		</t>
		<dl>
			<dt>sting:</dt><dd>A CBOR protocol data type.</dd>
			<dt>StingOfCharacters</dt>
			<dd>
				A user defined name for this array.
			</dd>
			<dt>Widget:</dt>
			<dd>
				An example of a a user defined data type.
			</dd>
			<dt>Array of Widget:</dt>
			<dd>
				A user defined name for this array.
			</dd>
			<dt>opaque:</dt><dd>A CBOR protocol data type.</dd>
			<dt>PNFFileData:</dt>
			<dd>
				A user defined name for this array.
			</dd>
		</dl>
		<t>
			The opaque data type represents data that is not
			encoded in any way.
			A PNG file is an example that does not get network byte order
			translated, it is sent as an opaque blob of unaltered data.
		</t>
		<t>
			A 'string' in CBOR represents a string of printable characters.
		</t>
	</section>
	<section>
		<name>Number of bits in value</name>
		<t>
			The CBOR protocol allows for bit value, and streams bits.
		</t>
		<t>
			In this specification terminal values may specify a bit width.
			Indicating the number of bits in the value.
		</t>
		<t>
			Where the "width" is the number of bits in the value.
			And must be an unsigned integer greater than zero.
			And is always expressed in decimal.
		</t>
		<t>
			When the left side of a rule has a width: 
			The number of bits on the left side must equal
			the number of bits on the right side.
		</t>
		<t>
			The most significant values are placed to the left of
			lesser signification values in the rule:
		</t>
		<t>
			In this example A Header is 32-bits in size
			and is composed of an 8-bit (Offset), 2-bit (Flags or F),
			and 22-bit (Length) value.
		</t>
		<figure anchor="Header32Example">
	<artwork align="left" type="abnf" name="" alt=""><![CDATA[
Header:32 = Offset:8 Flags:2 Length:22
]]></artwork>
</figure>
		<t>
			Example pseudo code for the ABNF in
			<xref target="Header32Example"/> could be:
		</t>
		<figure anchor="Header32ExamplePseudo">
		<sourcecode>

// Header is a 32-bit unsigned integer.
// Offset is an 8-bit unsigned integer.
// Flags (F) is a 2-bit unsigned integer.
// Length is a 22-bit unsigned integer
//
Header = (Offset &lt;&lt; 24) | (Flags &lt;&lt; 22) | Length;

		</sourcecode>
		</figure>

		<t>
			The pseudo code in
			<xref target="Header32ExamplePseudo"/>
			shifts the 8-bit "Offset" over 24 bits to the left, then
			shifts the 2-bit value "Flags (F)" over 22 bits,
			then, places the lower 24-bits "Length" into the results.

			The result would be all three values into the
			one 32-bit result as illustrated in <xref target="ABNF-00"/>:
		</t>

		<figure anchor="ABNF-00" align="center">
			<name>Packed Bit Example</name>
			<artset>
				<artwork align="center" type="ascii-art" src="Drawings/ABNF-00.txt"/>
				<artwork align="center" type="svg" src="Generated/ABNF-00.svg"/>
			</artset>
		</figure>
	</section>

	<section>
		<name>Common Definitions</name>
		<table>
			<name>Phoenix Protocol types</name>
			<thead>
				<tr>
					<th>
						TYPE
					</th>
					<th>
						Notes
					</th>
					<th>
						CBOR API
					</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>
						uint8_t
					</td>
					<td>
						<t>
							An 8-bit unsigned integer.
						</t>
					</td>
					<td>
						cbor_uint8_t()
					</td>
				</tr>
				<tr>
					<td>
						uint16_t
					</td>
					<td>
						<t>
							A 16-bit unsigned integer.
						</t>
					</td>
					<td>
						cbor_uint16_t()
					</td>
				</tr>
				<tr>
					<td>
						uint32_t
					</td>
					<td>
						<t>
							A 32-bit unsigned integer.
						</t>
					</td>
					<td>
						cbor_uint32_t()
					</td>
				</tr>
				<tr>
					<td>
						uint64_t
					</td>
					<td>
						<t>
							A 64-bit unsigned integer.
						</t>
					</td>
					<td>
						cbor_uint64_t()
					</td>
				</tr>
				<tr>
					<td>
						string
					</td>
					<td>
						<t>
							A string of UTF-8 characters.
						</t>
					</td>
					<td>
						cbor_string()
					</td>
				</tr>
				<tr>
					<td>
						opaque
					</td>
					<td>
						<t>
							An array of 8-bit values that will not be
							CBOR encoded or CBOR decoded when transferring the data
							over this protocol.
						</t>
					</td>
					<td>
						cbor_opaque()
					</td>
				</tr>
				<tr>
					<td>
						Op
					</td>
					<td>
						An 8-bit value.
						When the highest bit is one (1)
						it is a vendor specific Op.
						Otherwise, it is set to zero (0).
					</td>
					<td>
						cbor_Op()
					</td>
				</tr>
				<tr>
					<td>
						OpSet
					</td>
					<td>
						An 8-bit value.
						Signifies the operation will set a value.
						This is used in a few places to signify
						the operation to apply to any included data.
					</td>
					<td>
						cbor_Op() With the value cat to a (Op).
					</td>
				</tr>
				<tr>
					<td>
						OpGet
					</td>
					<td>
						An 8-bit value.
						Signifies the operation will get a value.
					</td>
					<td>
						cbor_Op() With the value cat to a (Op).
					</td>
				</tr>
				<tr>
					<td>
						OpUpdate
					</td>
					<td>
						An 8-bit value.
						Signifies the operation will update an existing value.
					</td>
					<td>
						cbor_Op() With the value cat to a (Op).
					</td>
				</tr>
				<tr>
					<td>
						OpDelete
					</td>
					<td>
						An 8-bit value.
						Signifies the operation will delete key/value pair.
					</td>
					<td>
						cbor_Op() With the value cat to a (Op).
					</td>
				</tr>
				<tr>
					<td>
						true
					</td>
					<td>
						An 8-bit value.
						A value of true.
					</td>
					<td>
						cbor_false()
					</td>
				</tr>
				<tr>
					<td>
						false
					</td>
					<td>
						An 8-bit value.
						A value of false.
					</td>
					<td>
						cbor_true()
					</td>
				</tr>
				<tr>
					<td>
						enabled
					</td>
					<td>
						A true or false value.
					</td>
					<td>
						cbor_enabled()
					</td>
				</tr>
				<tr>
					<td>
						Unused7
					</td>
					<td>
						A 7-bit value, set to zeros.
					</td>
					<td>
					</td>
				</tr>
				<tr>
					<td>
						Unused8
					</td>
					<td>
						An 8-bit value, set to zeros.
					</td>
					<td>
					</td>
				</tr>
				<tr>
					<td>
						Unused16
					</td>
					<td>
						A 16-bit value, set to zeros.
					</td>
					<td>
					</td>
				</tr>
				<tr>
					<td>
						Unused23
					</td>
					<td>
						A 23-bit value, set to zeros.
					</td>
					<td>
					</td>
				</tr>
				<tr>
					<td>
						VENDOR_BIT
					</td>
					<td>
						A 1 bit value, set to 1.
						It is placed in the highest bit
						position in the value.
					</td>
					<td>
					</td>
				</tr>
				<tr>
					<td>
						PHOENIX_BIT
					</td>
					<td>
						A 1 bit value, set to 0.
						It is placed in the highest bit
						position in the value.
					</td>
					<td>
					</td>
				</tr>
			</tbody>
		</table>
	</section>

	<section anchor="StringRef">
		<name>StringRef</name>
		<t>
			This protocol references strings in existing MIME objects
			by octet offset into the MIME object.
			This is is called a StringRef.
			All strings can be referenced by using a total of 8 octets.
			The StringRef does not contain the string, it is a 
			reference an existing string in a MIME object.
			A StringRef consists of two parts:
		</t>
		<table>
			<name>StringRef ABNF/CBOR Mapping</name>
			<thead>
				<tr>
					<th>Name</th>
					<th>Description</th>
					<th>CBOR API</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>Offset</td>
					<td>
						The octet count to the start of the string with zero being the
						first octet in the message.
					</td>
					<td>
						cbor_Offset()
					</td>
				</tr>
				<tr>
					<td>Length</td>
					<td>
						The length in octets of the string.
					</td>
					<td>
						cbor_Length()
					</td>
				</tr>
				<tr>
					<td>StringRef</td>
					<td>
						A String reference object.
					</td>
					<td>
						cbor_StringRef()
					</td>
				</tr>
			</tbody>
		</table>
		<t>
			A StringRef over the wire is 8 octets in size.
		</t>
		<figure anchor="StringRefFigure" align="center">
			<name>StringRef Format</name>
			<artset>
				<artwork align="center" type="ascii-art" src="Drawings/StringRef-00.txt"/>
				<artwork align="center" type="svg" src="Generated/StringRef-00.svg"/>
			</artset>
		</figure>

		<t>
			ABNF:
		</t>
	</section>
	
</section>
<!-- [CHECK] The 'Requirements Language' section is optional -->
