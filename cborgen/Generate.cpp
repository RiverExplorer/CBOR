/**
 * Project: Phoenix
 * Time-stamp: <2025-05-24 20:05:19 doug>
 * 
 * @file Generate.cpp
 * @author Douglas Mark Royer
 * @date 24-FEB-2025
 * 
 * @Copyright(C) 2025 by Douglas Mark Royer (A.K.A. RiverExplorer)
 * 
 * Licensed under the MIT License. See LICENSE file
 * or https://opensource.org/licenses/MIT for details.
 * 
 * RiverExplorer is a trademark of Douglas Mark Royer
 */

#ifndef W64
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#endif

#include "cborgen.hpp"
#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>

#include "antlr4-runtime.h"
#include "cborLexer.h"
#include "cborParser.h"
#include "cborListener.h"
#include "cborBaseListener.h"

#include <unistd.h>
#include <getopt.h>
#include <fcntl.h>
#include <sys/stat.h>

#include "Generate.hpp"

#include <iostream>

using namespace antlr4;
using namespace std;

namespace RiverExplorer::cborgen
{
	extern std::string	Indent(int Level);
	// List of user defined types.
	//
	std::set<UserType*, UserTypeComparator>	UserDefinedTypes;

	std::string
	Replace(const std::string In, char Old, char With)
	{
		std::string Results = In;

		for (size_t i = 0; i < Results.length(); i++) {
			if (Results[i] == Old) {
        Results[i] = With;
			}
		}

		return(Results);
	}
	
	bool
	MakePath(const string PathToMake)
	{
		bool Results = false;
		
		// Break it down and make the parts.
		//
		string Path;
		string::const_iterator SIt;

		for (SIt = PathToMake.cbegin(); SIt != PathToMake.cend(); SIt++) {
			if (*SIt != '/' && *SIt != '\\') {
				Path += *SIt;
			} else {
				// If it does not exist.
				//
				mkdir(Path.c_str(), 0755);
				Path += '/';
			}
		}
		mkdir(Path.c_str(), 0755);
		
		if (access(PathToMake.c_str(), R_OK|W_OK|X_OK) == F_OK) {
			Results = true;
		} else {
			cerr
				<< "ERROR: Can not make or write to path:" << PathToMake
				<< endl;
		}

		return(Results);
	}
	
}

namespace RiverExplorer::cborgen
{

	string
	RemoveFileExtension(string FileName)
	{
		string Results;
	
		size_t	LastDot = FileName.find_last_of('.');

		if (LastDot == string::npos) {
			Results = FileName;
		} else {
			Results = FileName.substr(0, LastDot);
		}

		return(Results);
	}
	
	static vector<string> CborBuiltInTypes = {
		"bool",
		"class",
		"char",
		"emum",
		"float16_t",
		"float32_t",
		"float64_t",
		"int",
		"int8_t",
		"int16_t",
		"int32_t",
		"int64_t",
		"opaque",
		"string",
		"struct",
		"uint"
		"uint8_t",
		"uint16_t",
		"uint64_t"
	};
	
	bool IsBuiltInCborType(const string & Type)
	{
		bool Results = false;

		std::vector<string>::const_iterator it;
		
		for (it = CborBuiltInTypes.cbegin()
					 ; it != CborBuiltInTypes.cend()
					 ; it++) {
			if (Type == *it) {
				Results = true;
				break;
			}
		}
		
		return(Results);
	}

	string
	Indent()
	{
		static string LastResults;
		static int LastIndent = 10000;
		
		string Results;

		if (IndentLevel != LastIndent) {
			int Tmp = IndentLevel;

			while (Tmp-- > 0) {
				Results += '\t';
			}
			LastIndent = IndentLevel;
			LastResults = Results;
		} else {
			Results = LastResults;
		}

		return(LastResults);
	}
		 
	string
	Indent(int Level)
	{
		string Results;

		int Tmp = Level;

		while (Tmp-- > 0) {
			Results += '\t';
		}

		return(Results);
	}
	
	string
	ToUpper(const string & In)
	{
		string Results = In;
	
		transform(Results.begin(),
							Results.end(),
							Results.begin(),
							[](unsigned char c) {return toupper(c);}
							);

		return(Results);
	}

	void
	GenerateThisFileWasGenerated(string Prefix,
															 ostream & Stream)
	{
		Stream << Prefix << "DO NOT EDIT THIS FILE" << endl
					 << Prefix << endl
					 << Prefix
					 << "It was generated from: " << InputFileName << endl
		
					 << Prefix
					 << "Using RiverExplorer cborgen program." << endl
		
					 << Prefix
					 << "Available at: https://github.com/RiverExplorer/Phoenix ."
					 << endl;

		return;
	}

	void
	GenerateEditThisFile(string Prefix,
											 ostream & Stream)
	{
		Stream << Prefix << "EDIT THIS FILE AND PUT IN YOUR IMPLEMENTATION" << endl
					 << Prefix << endl
					 << Prefix
					 << "It was generated from: " << InputFileName << endl
		
					 << Prefix
					 << "Using RiverExplorer cborgen program." << endl
		
					 << Prefix
					 << "Available at: https://github.com/RiverExplorer/Phoenix ."
					 << endl;

		return;
	}

	void
	GenerateUserDefinedTypes(std::ostream & Stream)
	{
	}

	void
	AddToUserDefinedTypes(std::string AUserType, std::string TypeFile)
	{
		if (!IsBuiltInCborType(AUserType)) {
			UserType * U = new UserType();

			U->Name = AUserType;
			U->File = TypeFile;
			UserDefinedTypes.insert(U);
		}

		return;
	}

	void
	GenerateIncludes(std::ostream & Out)
	{
		std::set<UserType*, UserTypeComparator>::const_iterator it;

		string I = Indent();
		
		UserType * U;
		
		PrintCppNamespaceBegin(Out);
		
		for (it = UserDefinedTypes.cbegin()
					 ; it != UserDefinedTypes.cend()
					 ; it++) {
			U = *it;

			if (!IsBuiltInCborType(U->Name)) {
				Out << endl
						<< I << "/**" << endl
						<< I << " * CBOR Encode " << U->Name << "." << endl
						<< I << " *" << endl
						<< I << " * @param Out An initialized ostream." << endl
						<< I << " *" << endl
						<< I << " * @param VariableName A reference to the variable to encode." << endl
						<< I << " *" << endl
						<< I << " * @return Out" << endl
						<< I << " */" << endl
						<< I << "extern std::ostream & operator<<(std::ostream & Out, const "
						<< U->Name << " & VariableName);" << endl
						<< endl
				
						<< I << "/**" << endl
						<< I << " * Decode a CBOR value: " << U->Name << "." << endl
						<< I << " *" << endl
						<< I << " * @param In An initialized istream." << endl
						<< I << " *" << endl
						<< I << " * @param[in] VariableName A reference to the variable to decode into." << endl
						<< I << " *" << endl
						<< I << " * @return In" << endl
						<< I << " */" << endl
						<< I << "extern std::istream & operator>>(std::istream & In, "
						<< U->Name << " & VariableName);" << endl
						<< endl;
			}
		}
		PrintCppNamespaceEnd(Out);

		return;
	}
	
}
